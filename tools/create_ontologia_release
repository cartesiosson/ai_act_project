#!/bin/bash

set -e

# === Configuraci√≥n ===
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_DIR="$(cd "$SCRIPT_DIR/.." && pwd)"

ENV_FILE="$SCRIPT_DIR/ontologias.env"
ONTOLOGY_DIR="$PROJECT_DIR/ontologias"
VERSION_ROOT="$ONTOLOGY_DIR/versions"

# === Funciones auxiliares ===
increment_version() {
    local version=$1
    local mode=$2
    IFS='.' read -r major minor patch <<< "$version"
    case "$mode" in
        major) ((major++)); minor=0; patch=0 ;;
        minor) ((minor++)); patch=0 ;;
        patch) ((patch++)) ;;
        *) echo "Error: modo de release inv√°lido '$mode'" ; exit 1 ;;
    esac
    echo "$major.$minor.$patch"
}

generate_ontology_header() {
    local base_iri=$1
    local version=$2
    local today=$(date +%Y-%m-%d)

    cat <<EOF
<${base_iri}>
    a owl:Ontology ;
    owl:versionIRI <${base_iri}/${version}> ;
    owl:versionInfo "Versi√≥n ${version} publicada el ${today}"@es ,
                    "Version ${version} released on ${today}"@en ;
    rdfs:comment "Ontolog√≠a del AI Act modularizada para representar sistemas inteligentes, actores regulados, niveles de riesgo y requisitos normativos bajo el marco legal europeo."@es ,
                 "Modular ontology for representing intelligent systems, regulated actors, risk levels, and compliance requirements under the European AI Act."@en ;
    dcterms:created "${today}"^^xsd:date ;
EOF
}

generate_master_imports() {
    local version=$1
    cat <<EOF

#################################################################
# Ontolog√≠a AI-Act ‚Äúmaestra‚Äù que importa todos tus m√≥dulos TTL  #
#################################################################

    # IMPORTA CADA UNO DE TUS FICHEROS .ttl
    owl:imports  
        <file:actors_intl-v${version}.ttl>,
        <file:compliance_intl-v${version}.ttl>,
        <file:core_intl-v${version}.ttl>,
        <file:governance_intl-v${version}.ttl>,
        <file:identifiers_intl-v${version}.ttl>,
        <file:interop_intl-v${version}.ttl>,
        <file:purpose_intl-v${version}.ttl>,
        <file:requirement_intl-v${version}.ttl>,
        <file:risk-assessment_intl-v${version}.ttl>,
        <file:risk_intl-v${version}.ttl> 
    .
EOF
}

# === Validaci√≥n de argumentos ===
if [[ "$1" != "--release" || ! "$2" =~ ^(minor|major|patch)$ ]]; then
    echo "Uso: ./create_ontologia_release --release minor|major|patch [--ok]"
    exit 1
fi

# === Leer versi√≥n actual ===
if [[ ! -f "$ENV_FILE" ]]; then
    echo "Error: archivo $ENV_FILE no encontrado en $SCRIPT_DIR"
    exit 1
fi

source "$ENV_FILE"
CURRENT_VERSION="$CURRENT_RELEASE"
NEW_VERSION=$(increment_version "$CURRENT_VERSION" "$2")

echo "Generando nueva versi√≥n: $NEW_VERSION (desde $CURRENT_VERSION)"

# === Crear subcarpeta para la nueva versi√≥n ===
VERSION_DIR="$VERSION_ROOT/$NEW_VERSION"
mkdir -p "$VERSION_DIR"

echo "Guardando archivos TTL versionados en: $VERSION_DIR"

# === Procesar cada archivo TTL ===
UPDATED_FILES=()
for ttl_file in "$ONTOLOGY_DIR"/*.ttl; do
    filename=$(basename "$ttl_file")
    basename_raw="${filename%.ttl}"
    basename=$(echo "$basename_raw" | sed -E 's/(-v[0-9]+\.[0-9]+\.[0-9]+)+$//')
    versioned_file="${VERSION_DIR}/${basename}-v${NEW_VERSION}.ttl"
    base_iri="http://ai-act.eu/${basename}"

    # Leer contenido
    ttl_content=$(<"$ttl_file")

    # Extraer prefijos √∫nicos y ordenarlos
    prefix_block=$(echo "$ttl_content" | grep '^@prefix' | sort -u)

    # A√±adir obligatorios si faltan (solo en ai-act-master.ttl)
    if [[ "$basename" == "ai-act" ]]; then
        [[ "$prefix_block" != *"@prefix rdfs:"* ]] && prefix_block="$prefix_block
@prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> ."
        [[ "$prefix_block" != *"@prefix dcterms:"* ]] && prefix_block="$prefix_block
@prefix dcterms: <http://purl.org/dc/terms/> ."
        [[ "$prefix_block" != *"@prefix xsd:"* ]] && prefix_block="$prefix_block
@prefix xsd: <http://www.w3.org/2001/XMLSchema#> ."
    fi

    # Ordenar los prefijos
    prefix_block=$(echo "$prefix_block" | awk '
        /@prefix owl:/ {print "01 "$0; next}
        /@prefix rdf:/ {print "02 "$0; next}
        /@prefix rdfs:/ {print "03 "$0; next}
        /@prefix xsd:/ {print "04 "$0; next}
        /@prefix dcterms:/ {print "05 "$0; next}
        {print "10 "$0}' | sort | cut -d' ' -f2-)

    # Extraer cuerpo sin prefijos ni definici√≥n previa de Ontology (solo ai-act-master)
    body_block=$(echo "$ttl_content" | awk '!/^@prefix/')
    if [[  "$basename" == "ai-act" ]]; then
        # clean_body=$(echo "$body_block" | awk -v iri="<http://ai-act.eu/ai-act-master>" '
        #     $0 ~ "^" iri "[[:space:]]+a[[:space:]]+owl:Ontology" {skip=1; next}
        #     skip && /^\s*\./ {skip=0; next}
        #     !skip')
        clean_body=""
    else
        clean_body=$(echo "$body_block" | awk 'BEGIN{skip=0} 
            /a owl:Ontology/ {skip=1} 
            skip && /^\s*\./ {skip=0; next} 
            !skip')
    fi

    # Generar contenido final
    {
        echo "$prefix_block"
        echo ""
        if [[  "$basename" == "ai-act" ]]; then
            generate_ontology_header "$base_iri" "$NEW_VERSION"
            generate_master_imports "$NEW_VERSION"
            echo ""
        fi
        echo "$clean_body"
    } > "$versioned_file"

    echo "‚úî Archivo versionado: $versioned_file"
    UPDATED_FILES+=("$filename")

    # Sustituir fichero original por su versi√≥n si se solicita --ok
    if [[ "$3" == "--ok" ]]; then
        target_path="$ONTOLOGY_DIR/$filename"
        rm -f "$target_path"
        cp "$versioned_file" "$ONTOLOGY_DIR"
        echo "üîÅ Sustituido $filename con versi√≥n $NEW_VERSION"
    fi

done

# === Actualizar ontologias.env ===
echo "CURRENT_RELEASE=$NEW_VERSION" > "$ENV_FILE"
echo "‚úÖ Versi√≥n actualizada a $NEW_VERSION"
